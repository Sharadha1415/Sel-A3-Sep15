Selenium    :   To test the web-applications, we go for selenium

To install selenium
    Go to command prompt    --> pip install selenium
    The above command will install the latest version of selenium.

    To install the specific version of selenium
    Go to command prompt    --> pip install selenium==version

To check if selenium is installed properly or not
    Go to command prompt    --> pip show selenium
    This command will give the name, version, location and other details of selenium.

To check selenium version
    import selenium
    selenium.__version__

To check if selenium is available in the project
    Go to file --> Settings --> Project : ProjectName --> python interpreter --> This gives the list of all the available packages
    --> Check for selenium
    If selenium is available, then we have selenium in the project
    If selenium is not there, then selenium is not available in the project

    When selenium is not available, click on "+" and then give the package name and then click on install package

In command prompt
    *   pip list        --> This gives the list of all the installed packages
    *   pip --version   --> This gives the version of pip

########################################################################################################

Initialization of Chrome browser
    from selenium import webdriver
    driver = webdriver.Chrome()

    The above command will close the browser automatically.
    To prevent the browser from automatically closing, we use the  below syntax

    from selenium import webdriver
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("detach", True)
    driver = webdriver.Chrome(opts)

##---------------------------------------------------------------------------------------------------

Initialization of Firefox browser
    from selenium import webdriver
    driver = webdriver.Firefox()

    Firefox will not close automatically. So no need to consider FirefoxOptions

##---------------------------------------------------------------------------------------------------

Initialization of Edge browser
    from selenium import webdriver
    driver = webdriver.Edge()

    The above command will close the browser automatically.
    To prevent the browser from automatically closing, we use the  below syntax

    from selenium import webdriver
    opts = webdriver.EdgeOptions()
    opts.add_experimental_option("detach", True)
    driver = webdriver.Edge(opts)

########################################################################################################

SELENIUM ARCHITECTURE

CLIENT LIBRARIES / LANGUAGE BINDINGS
•	Selenium supports multiple languages such as Python, Java, C#, JavaScript, Ruby.
•	Client libraries provide various methods to perform different browser actions. e.g. get, title, find_element.
•	As automation developers we call these methods from our development environment. e.g. VSCode
•	Once we execute the script, the client libraries convert our code that we have written into a JSON (JavaScript Object Notation) format and sent as a request to Driver over HTTP.

BROWSER DRIVERS
•	Each browser has its own implementation of "WebDriver" protocol (mandatory services that needs to be implemented in order for selenium to interact with browser) called drivers.
•	The browser drivers are responsible for controlling the actual browsers since the browser implementation details will be known only to the developer of driver.
•	Each browser driver will be maintained by respective browser vendor. e.g. Chrome Driver is maintained by Google and Safari Driver is maintained by Apple.
•	Each method in the client library is mapped to a specific web-service in the driver.
•	The driver interprets the incoming request from the client and controls the actual browser.
•	Once the browser operation is complete, the response is sent back to the client/client library by driver in JSON format.
•	Client library interprets the JSON response and prints the response in readable format in the editor console.


############################################################################################################

Selenium3   :   We had to install the driver objects.
                Depending on the browser version, we had to install the specific version of driver.
                And we had to update the driver whenever browser gets updated
                SYNTAX  :   from selenium import webdriver
                            driver = webdriver.Browser(executable_path="path_of_driver")

Selenium4   :   No need to install the driver objects.
                Everything is taken care internally
                SYNTAX  :   from selenium import webdriver
                            driver = webdriver.Browser()

############################################################################################################

To launch the application       :   driver.get("url")
To maximize window              :   driver.maximize_window()
To minimize window              :   driver.minimize_window()
To go back                      :   driver.back()
To go forward                   :   driver.forward()
To refresh                      :   driver.refresh()
To close the window             :   driver.close()
To close all the windows        :   driver.quit()


Few properties
    *   driver.current_url      :   This gives the url of the current_page
    *   driver.title            :   This gives the title of the page
    *   driver.name             :   This gives the name of the browser

To take screenshots
    driver.save_screenshot("name.png")
    This command will save the screenshot in the same package as the python file

    To save the screenshot in different location
    driver.save_screenshot("location\name.png")

############################################################################################################

WEB-ELEMENT METHODS     :   To interact with the web-elements, we have web-element methods
There are 2 types of web-element methods
*   find_element    :   To find and to interact with only one element, we go for find_element.
                        Interacts only with one occurance(if multiple elements are there then interacts with first occurance)
                        Return type is a web-element.
                        If the locator value is wrong then we will get NoSuchElementException
                        SYNTAX  :   driver.find_element("locator_name", "locator_value")

*   find_elements   :   To find and to interact with multiple elements, we go for find_elements
                        Can interact with all the occurances
                        Return type is a list of web-elements.
                        If the locator value is wrong, it will give empty list
                        SYNTAX  :   driver.find_elements("locator_name", "locator_value")

############################################################################################################

LOCATORS    :   To locate the web-elements, we go for locators
There are 8 types of locators

    *   id      :   id is an attribute which is also the locator
                    If we have "id" attribute, then we can go for "id" locator
                    SYNTAX      :   driver.find_element('id', 'id_value')

    *   name    :   name is an attribute which is also the locator
                    If we have "name" attribute, then we can go for "name" locator.
                    name is not unique
                    Incase of multiple occurances, name will always consider the first occurance

                    SYNTAX      :   driver.find_element('name', 'name_value')

    *   class name  :   class is an attribute.
                        If we have "class" attribute, then we can go for "class name" locator.
                        DRAWBACKS
                        *   class name is not unique
                            Incase of multiple occurances class name will always consider the first occurance.
                        *   class name cannot locate the spaces.
                            Whenever there is a space in the value of the class attribute, we have to replace the space with dot(.)

                    SYNTAX      :   driver.find_element('class name', 'class_name_value')


    *   tag name    :   We can locate the web-elements using tagname of the web-element.
                        But tagname can only consider the first occurance
                        SYNTAX      :   driver.find_element('tag name', 'tagname')


    *   link text   :   The text present between the anchor tag, we call it as a link text.
                        To locate the link text, we use "link text" locator
                        link text can only be used if the tag is anchor
                        SYNTAX  :   driver.find_element("link text", "text")

    *   partial link text   :   Same as link text. Here also the text should be present between the anchor tag.
                                But instead of locating the web-element using complete text, we can locate the web-elements by using
                                    partial portion of the text.
                                To locate the partial text present between the anchor tag we go for partial link text
                        SYNTAX  :   driver.find_element("partial link text", "partial text")

   *    css selector    :   To locate the web-elements using any attribute, we go for css selector
                        SYNTAX  :   tagname[attr_name="attr_value"]
                        DRAWBACKS
                        *   Indexing is not possible.
                            Incase of multiple occurances, css selector will always consider first occurance
                        *   Cannot locate text using css selector
                        *   Backtraversing is not possible
                        SYNTAX  :   driver.find_element("css selector", "tagname[attr_name='attr_value']")

    *   xpath       :   To locate the web-elements uniquely on the web-application, we go for xpath
                        There are 2 types of xpaths
                        *   absolute xpath  :   Starts from the root of html
                                                We use / to write the absolute xpath
                                                / represents immediate child

                        *   relative xpath  :   Doesnot start from the root of html
                                                We use // to write the relative xpath
                                                // represents any child

                            Attributes      :   //tagname[@attr_name="attr_value"]
                                                @ represnts attributes
                            Text            :   //tagname[text()="text"]
                            Group indexing  :   (any_xpath)[index_num]
                            Contains        :   To locate the partial text of any tagname we go for contains
                                                //tagname[contains(text(), "partial text")]

                            Dependent independent xpath
                                *   Identify independent-dependent elements.
                                *   Write the xpath of the independent element
                                *   Traverse back until we get the common match for dependent-independent element
                                *   Continue writing the xpath of dependent element

                            starts-with     :   //tagname[starts-with(@attr_name, "attr_value")]
                            ends-with       :   //tagname[ends-with(@attr_name, "attr_value")]      ## Doesnot work

############################################################################################################

SYNCHRONIZATION     :   Matching the speed of the web-driver to the web-application
There are 2 types of synchronization
*   unconditional synchronization    :   No conditions are passed
            We achieve unconditional synchronization by passing time.sleep(n)
            Unnecessary wait is too much

*   conditional synchronization     :   Conditions are passed
    There are 2 types
    *   implicit_wait   :   Conditions are internally given
                            SYNTAX  :   driver.implicitly_wait(n)
                            *   One implicit_wait is sufficient for the whole program
                            *   No unnecessary wait
                                It will wait for maximum of n seconds, as soon as the element is located it will perform the operations.

    *   explicit_wait   :   Conditions are externally given.
            We have to import few statements

            from selenium.webdriver.support.ui import WebDriverWait             ## WebDriverWait --> class
            from selenium.webdriver.support import expected_conditions          ## expected_conditions --> module

            wait_obj = WebDriverWait(driver, timeouttime)

            ## To give the conditions
            wait_obj.until(expected_conditions.condition)

############################################################################################################

LISTBOXES/DROPDOWNS     :   Whenever we have a dropdown, first we have to check the tagname of the dropdown.
    If the tagname of the dropdown/listbox is "select", then it is a standard listbox.
    We have two types
    *   single-select listbox   :   Here we can choose only one element from the dropdown
    *   multi-select listbox    :   Here we can choose multiple elements from the dropdown

    We handle single-select as well as multi-select listbox in the same way.

    To perform the operations in the standard listbox, we should go for "Select" class

    from selenium.webdriver.support.select import Select
        select --> module
        Select --> class

    select_obj = Select(listbox_having_select_tag)

    We have 3 attributes to select the elements from the dropdown
    *   select_by_index         :   Will select the elements of the dropdown by passing the index number
                                    SYNTAX  :   select_obj.select_by_index(index_num)

    *   select_by_value         :   Will select the elements of the dropdown by passing the value of the value attribute
                                    SYNTAX  :   select_obj.select_by_value("value")

    *   select_by_visible_text  :   Will select the elements of the dropdown by passing the text visible
                                    SYNTAX  :   select_obj.select_by_visible_text(text)

    NOTE    :   If the listbox is not standard, then we have to locate the web-elements and click on it

############################################################################################################

ALERTS  :   Alerts are not inspectable. If we can inspect it, then it is not an alert.
            To handle the alert, we should switch the driver to the alert

            SYNTAX  :   alert_obj = driver.switch_to.alert
                        alert_obj has two attributes to handle the alert
                        *   accept()    :   To accept the alert, we use this
                                            SYNTAX  :   alert_obj.accept()
                        *   dismiss()   :   To dismiss the alert, we use this
                                            SYNTAX  :   alert_obj.dismiss()

            There are different types of alerts
            *   Simple alert    :   If the alert is having only one option, then we call it as simple alert
                We can handle simple alert by using alert_obj.accept() or alert_obj.dismiss()

            *   Confirmation alert  :   This alert asks for user confirmation.
                Usually confirmation alert will have two options, OK/CANCEL, YES/NO, AGREE/DISAGREE,..
                To click on OK/YES/AGREE,.      --> alert_obj.accept()
                To click on CANCEL/NO/DISAGREE  --> alert_obj.dismiss()

            *   Prompt alert    :   In prompt alert, we have to pass the data to the alert
                    alert_obj.send_keys(data)
                    alert_obj.accept()

            *   Authentication pop-up   :   Here we have to pass the username and password while launching the application only.
                    We will pass the username and password in the url
                    SYNTAX  :   https://username:password@url

            *   file-upload pop-up  :
                    file_path = r'absolute_path_of_file_to_be_uploaded'
                    web_element.send_keys(file_path)

            *   push notifications  :   The notifications like "allow app to send notifications", these notifications
                we call them as push notifications
                We cannot predict them, so we disable them
                    from selenium import webdriver
                    opts = webdriver.BrowserOptions()
                    opts.add_argument("--disable-notifications")
                    driver = webdriver.Browser(opts)

############################################################################################################

ACTIONCHAINS    :   The operations performed using mouse/keyboard we call them as low-level operations.
    To perform low-level operations in selenium we go for ActionChains

    First we have to import ActionChains
    To perform keyboard related operations, we have to import Keys

    from selenium.webdriver.common.action_chains import ActionChains
    from selenium.webdriver.common.keys import Keys
        action_chains   --> module
        ActionChains    --> class
        keys            --> module
        Keys            --> class

    actionchain_obj = ActionChains(driver)

    Mouse hovering operations                       :   actionchain_obj.move_to_element(element).perform()
    Right click                                     :   actionchain_obj.context_click(element).perform()
    Double click                                    :   actionchain_obj.double_click(element).perform()
    Drag and drop                                   :   actionchain_obj.drag_and_drop(draggable_ele, droppable_ele).perform()
    Scrolling operations
        To scroll to a specific element             :   actionchain_obj.scroll_to_element(element).perform()
        To scroll till end of the page              :   actionchain_obj.send_keys(Keys.END).perform()
        To scroll back to the start of the page     :   actionchain_obj.send_keys(Keys.HOME).perform()
        Pagedown scrolling                          :   actionchain_obj.send_keys(Keys.PAGE_DOWN).perform()
        PageUp scrolling                            :   actionchain_obj.send_keys(Keys.PAGE_UP).perform()

############################################################################################################

WINDOW HANDLING     :   It is used when a web-application opens multiple browser windows or tabs and to handle the
    multiple windows or tabs, we should switch between them to perform the operations

    window_handles = This is a property. This returns a list of all the open window handles

    First we will initialize the window_handles
    handles = driver.window_handles     ## list of handles, [parent_handle, child_handle...]

    To switch the driver to different window
    SYNTAX  :   driver.switch_to.window(handles[index_num])

    By default driver will be present in the parent window

############################################################################################################

IFRAMES     :   Iframe stands for inline frame
                A web-application present inside another web-application.
                We cannot interact with the elements present inside the iframe.
                So we switch the driver from the main application to the frame.
                The tagname of an iframe is always iframe

                To handle the iframes
                    *   Locate the iframe
                        frame = driver.find_element('loc_value', 'frame')
                    *   Switch the driver from the main app to the frame
                        SYNTAX  :   driver.switch_to.frame(frame)
                    *   Perform the operations inside the frame
                    *   Once after performing the operations inside the frame, switch back to the parent frame
                        SYNTAX  :   driver.switch_to.parent_frame()

############################################################################################################

READING EXCEL   :   We use xlrd to read the excel files

To install xlrd :   Go to command prompt    --> pip install xlrd==1.2.0

    STEP1       :   import xlrd
    STEP2       :   Open the excel file
                    workbook = xlrd.open_workbook("path_of_excel_file")                 ## Book object
    STEP3       :   Open the worksheet
                    worksheet = workbook.sheet_by_name("SheetName")                     ## Sheet object
    STEP4       :   Convert the sheet object to the generator object
                    rows = worksheet.get_rows()                                         ## generator object
    STEP5       :   Traverse or typecase or use the next() to fetch the data from the generator object

############################################################################################################

WRITING EXCEL   :   To write into the excel files we go for openpyxl
To install openpyxl
    Go to command prompt    --> pip install openpyxl

    STEP1   :   from openpyxl import Workbook
    STEP2   :   create the excel workbook
                workbook = Workbook()
    STEP3   :   Initialize the active worksheet
                worksheet = workbook.active
    STEP4   :   Set the title for the worksheet(optional)
                worksheet.title = "title"
    STEP5   :   Write the data into the excel
    STEP6   :   Save the excel file
                workbook.save("filename.xlsx")

############################################################################################################

PYTEST      :   It is a unit testing framework.
                Testing the small portion of the complete code is unit testing.
                To perform unit testing in selenium, we go for pytest

                *   Easy syntax
                *   Generate reports
                *   Supports cross browser testing

                To install pytest
                    Go to command prompt    --> pip install pytest

                RULES
                *   filename should always start with test_ or should end with _test
                    eg  :   test_filename.py    or      filename_test.py
                *   classnames should always start with Test
                    eg  :   class TestClassname:
                                pass
                *   function name should always start with test_
                    eg  :   def test_funcname():
                                pass

                Pytest will automatically recognize the files, classes, functions which are following the pytest rules.
                So without creating the object for the class or without calling the functions, we can execute them

                To execute the pytest files
                    Right click anywhere on the test_file   --> open in --> terminal --> pytest test_filename.py -vs
                        -v  --> Verbosity.  This gives the detailed explanation of the code
                        -s  --> Scripting.  This prints all the print statements

                To execute all the test_files present in the package
                    In terminal --> pytest -vs
                    This we call it as batch execution

                To execute only few test_files in the package
                    In terminal --> pytest test_file1.py test_file2.py test_file3.py -vs


NOTE
    *   test_functions/test_methods do not take any parameters. It takes only fixtures as parameters
    *   We should not call the test_functions or create the object for the TestClasses.
        Execution will happen twice
    *   Pytest cannot recognize the nested functions
        Incase of nested test_functions, it will recognize only the outer test_function
    *   Error in one testcase will not affect the execution of the other testcases
    *   TestClasses should not have __init__ constructor

############################################################################################################

FIXTURES    :   In pytest fixtures are commonly used to perform the setup and teardown operations.
                setup operation such as opening the browser and launching the application
                teardown operation such as closing the browser

                A fixture is a function which runs before and after the execution of the test_functions
                We use fixtures to avoid the repetition of the setup and teardown operation.

                SYNTAX  :   @pytest.fixture()
                            def func():
                                pass                ## setup
                                yield
                                pass                ## teardown

                            def test_func(func):
                                pass

                            The operations before yield acts as setup, i.e, it will execute before the execution of the test function
                            The operations after yield acts as teardown, i.e, it will execute after the execution of the test function

                            To apply the fixture for the test_function, we should pass the name of the fixture as a parameter for the test_functions

                Fixture has three parameters. All three are optional parameters
                *   autouse     :   When we give autouse=True, by default the fixture will be applied for all the test_functions/
                                    test_methods present in that module.
                                    When we use autouse=True, we dont have to give the fixture name as a parameter for the test functions

                *   scope       :   This defines the scope of the fixture.
                                    If scope="class", the fixture will be applied on a class level.
                                    The fixture will execute once for one class.
                                    Before the execution of the entire class, setup will be performed
                                    After the execution of the entire class, teardown will be performed

                                    If scope="module", the fixture will be applied on a module level.
                                    The fixture will execute once for entire module.
                                    Before the execution of the entire module, setup will be performed
                                    After the execution of the entire module, teardown will be performed

                                    If scope="session"
                                    The fixture will execute once for the entire session
                                    Before the execution of the entire session, setup will be performed
                                    After the execution of the entire session, teardown will be performed

                                    By default scope="function"

                *   params      :   To perform multiple-browser execution, we go for params

                                    SYNTAX  :   @pytest.fixture(params=['browser1', 'browser2', 'browser2'])
                                                def func(request):
                                                    parameter = request.param

                                                    if parameter = 'browser1':
                                                        driver = webdriver.Browser1()
                                                    elif parameter == 'browser2':
                                                        driver = webdriver.Browser2()
                                                    elif parameter == 'browser3':
                                                        driver = webdriver.Browser3()

############################################################################################################

CONFTEST    :   In pytest, conftest is a configuration test_file.
                In this file, we store the fixture(initialization of driver and launching of the web-app) that should
                    be applied for multiple test files.
                    We dont have to import the conftest file.
                    Pytest will automatically recognize the fixture present in the conftest.

                *   The filename should always be "conftest.py"
                *   The conftest file should be placed in the test_package

                *   To avoid the code(fixture) repetation
                *   To keep the browser setup in one place.

############################################################################################################

GENERATE REPORTS    :   We can generate html reports
        We have to install pytest-html to generate the reports
        Go to command prompt    -->     pip install pytest-html

        To generate the reports
        In terminal     --> pytest test_filename.py -vs --html="report_name.html"
        The above command will generate the report in the same location as our test_file

        To store the reports in some other location
        In terminal     --> pytest test_filename.py -vs --html="location\report_name.html"

############################################################################################################

MARKERS :   To group the testcases we go for markers
There are 2 types of markers
    *   inbuilt markers     :   There are 4 types of inbuilt markers
            *   skip        :   To skip the execution of the testcases we go for skip marker
                                This is an unconditional skip.
                                To skip the testcase we dont have to pass any condition or reason.
                                It will skip the testcases which are decorated with @pytest.mark.skip()

                                SYNTAX  :   @pytest.mark.skip([reason])
                                            def test_func():
                                                pass

                                reason is the optional parameter

            *   skipif      :   This also skips the execution of the testcases, but the skip is based on a condition.
                                This is a conditional skip.
                                To skip the testcases, here we should pass the condition as well as the reason.
                                Both are mandatory parameters

                                SYNTAX  :   @pytest.mark.skipif(condition, reason)
                                            def test_func():
                                                pass

                                            If the condition is True, then it will skip the execution of the testcase.
                                            If the condition is False, then it will execute the testcase

            *   parametrize :   When we pass the parameters for the test_functions, pytest will consider those parameters as fixtures.
                                To pass the parameters which are not fixtures, we use parametrize markers

                                SYNTAX  :   @pytest.mark.parametrize('args', [('actual_args')])
                                            def test_func(args):
                                                pass


            *   xfail       :   This is an expected failure.
                                We use @pytest.mark.xfail to test the test_func which is expected to fail.

                                *   A bug is tehre, but not fixed yet
                                *   We are passing invalid credential data and we are expecting the login to fail

                                SYNTAX  :   @pytest.mark.xfail
                                            def test_func():
                                                pass

                                            If the test_func fails, then our output will be XFAIL
                                            If the test_func passes, then our output will be XPASS


    *   custom markers      :   We can group the testcases by giving the names for the testcases and by grouping them.

                                SYNTAX  :   @pytest.mark.name       ## Can give any name
                                            def test_func():
                                                pass

                                To execute only the grouped testcases
                                In terminal --> pytest test_filename.py -vs -m="name"

                                If we dont want to execute a particular group
                                In terminal --> pytest test_filename.py -vs -m="not name"

############################################################################################################

DEPENDENCIES    :   We can make one test_func dependent on other test_func

                    In command prompt   --> pip install pytest-dependency

                    SYNTAX  :   @pytest.mark.dependency()       ## independent testcase
                                def test_func1():
                                    pass

                                @pytest.mark.dependency(depends=['test_func1'])     ## dependent testcase
                                def test_func2():
                                    pass

                                If the independent testcase executes without any error, then dependent also executes without any error
                                If the independent testcase fails, then dependent testcase will be skipped

                    We can have one dependent testcase, depending on multiple independent testcases
                      SYNTAX  :     @pytest.mark.dependency()       ## independent testcase
                                    def test_func1():
                                        pass

                                    @pytest.mark.dependency()       ## independent testcase
                                    def test_func2():
                                        pass

                                    @pytest.mark.dependency(depends=['test_func1', 'test_func2'])     ## dependent testcase
                                    def test_func3():
                                        pass

                                    In the above example, test_func3() depends on test_func1() and test_func2().
                                    If both the independent testcases executes without any error, then dependent also executes without any error
                                    If any one of the independent testcase fails, then the dependent testcase will be skipped

############################################################################################################

is_displayed    :   This will give True if the web-element is displayed on the application.
                    If the web-element is not displayed, then it will give False
                    SYNTAX  :   web_element.is_displayed()






























































































































































































